C++易错知识点

[TOC]

面向对象程序设计语言不同于其他语言的主要特点：**继承、封装、多态**

软件的本质特性：**一致性、复杂性、不可见性、可变性**

### 1、数组

#### 1.1、数组名永远不可能是指针

#### 1.2、数组名

```C++
int A[10][10]; int *p;

判断下列表达式的对错
P=A; // 错误，P与A类型不同
P=A[0]; // true
P=&A[0][0]; // true
```



### 2、字符串

#### 2.1、字符串的初始化

```C++
char ch[4] = {'s', 't', 'u', 'd'}; // 可以初始化，但输出有问题，输出为stud+乱码
char ch[5] = "stud"; // 可以初始化，输出正常 
```

#### 2.2、在c/c++中的说明

c/c++中没有字符串这种数据类型，只可以通过以下方式实现：

- 字符数组
- 指向字符的指针
- String标准库

2.3、字符串长度

```c++
char str[] = "ABCDE";
int len1 = sizeof(str)/sizeof(str[0]); 
// len1 = 6，会计算结束符'\0'

int len2 = strlen(str); 
// len2 = 5，不计算结束符的长度，因为该函数以'\0‘作为结束标志
```





### 3、基础

#### 3.1、预定义标识符

`define、include、printf、scanf`

预定义标识符可作为用户标识符

#### 3.2、动态存储申请

二者均在动态存储区（heap）上申请内存空间

C中，malloc、calloc函数

C++中，new函数

#### 3.3、`sizeof`

属于C语言中的一个操作符，不是函数调用，结果是无符号整数，因此可把它看作是无符号整型表达式。

##### 3.3.1、类的sizeof大小

- 只计算非静态成员和虚函数
- 虚函数按指针来计算
- 对齐方式，如#pragma pack(2)，表示强制设定为2字节对齐
- 空类的大小为1
- 枚举类型每个元素占1字节



#### 3.4、const 与 * 的结合

const 在 * 左侧，表示所指向的内容不可改变，如

```C++
const int* p; // p所指向的内容是常量
int const* p; // 同上
```

const 在 * 右侧，表示指针本身不可改变，如

```C++
int* const p; // p是常量，p指向的内容可变
```

同时修饰，如

```C++
const int* const p; // p是常量，p指向的内容也是常量
int const* const p; // 同上
```

#### 3.5、堆与栈

##### 3.5.1、数据结构

栈：先入后出；

堆：先入先出；

##### 3.5.2、存储位置

堆上创建动态数组

#### 3.6、优先级

##### 3.6.1、`++` 的优先级高于解引用 `*` 

```C++
y = *p++; 
// 等价于
{
	p = p+1;
	y = *p;
}
```

##### 3.6.2、`&&`的优先级 > `||` > `=`

##### 3.6.3、算数运算符 > 逻辑运算符 > 关系运算符

#### 3.7、C++不是类型安全的

如`bool`类型与`int`类型的转换

#### 3.8、条件表达式

条件语句 (n=0) 为假

条件语句 (n=非零值) 为真

#### 3.9、gcc

默认对齐数是 4，不是最大长度

#### 3.10、函数参数初始化

函数参数的默认值不允许为局部变量。局部变量在函数调用后才会被构造出来。

#### 3.11、C++异常处理机制

三大机制：检查、抛出、捕获

#### 3.12、进制

##### 3.12.1、八进制

C/C++中，一个数如果要指明它采用的是八进制，则必须在它的前面加上字母 `o`

#### 3.13、自增自减运算符

指针自增自减每次移动的偏移量时指针所指向对象的字节大小

3.14、原码、反码、补码

- 三者的形式一致
- 负数用其绝对值的原码的补码表示，如 -1的原码表示就是 其1原码的补码 

- 反码为原码的数值取反
- 补码为反码+1

假设在64位系统下：

 ```
  1 	原码：0X0000 0000 0000 0001
    	反码：0XFFFF FFFF FFFF FFF0
    	补码：0XFFFF FFFF FFFF FFFF
  -1	原码：0XFFFF FFFF FFFF FFFF
 ```

  

- 

### 4、多态性

- （编译时）静态：函数重载、运算符重载、模板实现
- （运行时）动态：虚函数实现

### 5、继承

5.1、公有继承

公有继承时，基类各成员属性不变，基类中的 private 成员被隐藏。派生类中成员只能访问基类中的public/protected成员，不能访问private成员；派生类的对象不能访问基类中的任何成员。

5.2、私有继承

私有继承时，基类中各成员属性均变为 private，并且基类中private成员被隐藏；派生类的成员也只能访问基类中的 public/protected成员，不能访问 private 成员；派生类的对象不能访问基类中的任何成员。

5.3、保护继承

保护继承时，基类中各成员属性均变为 protected，其他同上。


### 7、关键字 `friend`

用于声明友元，一个类中的成员函数可以是另一个类的友元。

友元函数访问对象的成员不受访问特性的影响

### 8、类

- 只有一个类被定义为基类时，才会把析构函数携程虚析构函数

#### 8.1、空类

一个空类默认一定生成

- 构造函数
- 拷贝构造函数
- 赋值操作符
- 引用操作符
- 析构函数

#### 8.2、虚函数

- 在成员函数的前面加上 virtual修饰符，可把该函数声明为虚函数
- 虚函数是另一类的友元函数，但不能是静态成员函数
- 基类中说明的纯虚函数在其他任何需要实例化的派生类中都必须实现
- 虚函数表建立在编译阶段

##### 8.2.1、纯虚函数

声明方式：

```
virtual void print() = 0;
```

##### 8.2.2、父类指针指向子类实例对象

当父类指针指向子类实例对象，调用普通重写方法时，会调用父类中的方法。而调用被子类重写的虚函数时，会调用子类中方法。

解释：子类中被重写的虚函数的运行方式是动态绑定的，与当前指向的类的实例的傅雷指针类型无关，仅和类实例对象本身有关。

#### 8.3、类方法与实例方法

所谓的类方法通常是指类的静态方法，其他的方法称为实例方法：

- 实例方法可以对但钱对象的实例变量进行操作，也可以对类变量进行操作；但类方法只能操作静态成员。
- 实例方法必须由实例对象来调用，而类方法除了可以由实例对象调用，还可以由类名直接调用

#### 8.4、操作符重载

不能被重载：

- 点操作符 `.` 
- 指向成员操作的指针 `,*` 或者 `->*`
- 条件操作符 `?:`
- 域操作符 `::`
- 预处理符号 `#`
- sizeof

#### 8.5、析构函数与构造函数

析构函数和构造函数都没有返回类型，也没有return语句

### 9、派生类

#### 9.1、简述

- 从基类接收成员
- 调整从基类接收的成员
- 在声明派生类时增加成员，体现了派生类对基类功能的扩充
- 在声明派生类时，还要自己定义派生类的构造函数

#### 9.2、派生类::基类

向上类型转换是隐式的，因为部分元素丢弃可以自动完成；

向下转换类型是显式的，因为不知道应该增加的值是什么



### 13、cin 与 cout

cin 是 istream 类的对象

cout 是 ostream 类的对象

### 14、内联函数

当函数代码较小且被频繁调用时，采用内联函数

### 15、动态绑定

动态绑定是面向对象程序设计语言的一种机制，实现了方法的定义，与具体的对象无关。而对方法的调用可关联于具体的对象。

### 16、数据结构

#### 16.1、用一维数组存储二叉树时，总是以层序遍历顺序存储

#### 16.2、线性结构与非线性结构

- 线性结构：有序数据元素的集合，如

线性表、栈、队列、双队列、数组、串（字符串）等

- 非线性结构：每个数据元素可能与零个或多个其他数据元素发生联系，如

三维数组、多维数组、广义表、树、图等

### 17、C语言

#### 17.1、一些函数

##### 17.1.1、`fseek(fp, -20L, 2`)函数

含义：将文件位置指针从文件末尾处退后20个字节

##### 17.1.2、fteil(fp)函数

作用：得到流式文件中的当前位置

#### 17.2、C语言中最简单的数据类型

包括：整型、实型、字符型

#### 17.3、C语言的标识符不能以数字开头

### 18、设计模式

#### 18.1、单例模式

单例会构造方法声明为私有，但是会提供一个public静态方法，用来获取对象实例

### 19、函数模板

- 函数模板必须是由编译器根据程序员的调用类型实例化为可执行的函数
- 模板的成员函数都是函数模板
- 没有用过的成员函数（即函数模板）不会被实例化

### 20、线程

每个线程都有一个栈，用于保存自己的局部变量

多线程调用时要进行现场保护，变量中主要保护全局变量和静态变量







代码

1、数组

```C++

```



2、类

```C++
若 Student 是一个类，则
Student a(); // 没有创建对象，这里不是使用默认构造函数，而是定义了一个函数，是函数声明
Student a; // 创建了一个对象，调用无参构造函数
Student &a1 = a; // a1引用a，没有创建对象
Student b(2); //创建了一个对象，隐式调用构造函数
Student c = b; // 使用拷贝构造函数创建了一个新对象c
Student *p1 = &b; // 创建了一个类指针，没有构造对象
Student *p = new Student(4); // 创建一个类指针p，p指向一个新建的对象
```

