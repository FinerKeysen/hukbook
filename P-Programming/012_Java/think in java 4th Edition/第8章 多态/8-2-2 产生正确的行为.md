

当知道Java中所有方法都是通过动态绑定实现多态后，就可以编写只与基类交互的程序代码了，并且这些代码对所有的导出类都可以正确运行。也即是说，发生消息给某个对象，让该对象去断定应该做什么事情。

举例，有一个基类Shape，以及多个导出类，如Circle、Square、Triangle等。

Shape

```java
/**
 * @FilePath Polymorphism/Shape.java
 * @Author
 * @Date 2019/9/7 17:39
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

public class Shape {
    public void draw() {}
    public void erase() {}
}/* Shape output

 *///:~
```

Circle

```java
/**
 * @FilePath Polymorphism/Circle.java
 * @Author
 * @Date 2019/9/7 17:39
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Shape;import static hkeysen.utils.Print.print;

public class Circle extends Shape {
    public void draw() { print("Circle.draw()"); }
    public void erase() { print("Circle.erase()"); }
}/* Circle output

 *///:~
```

Square

```java
/**
 * @FilePath Polymorphism/Square.java
 * @Author
 * @Date 2019/9/7 17:40
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Shape;import static hkeysen.utils.Print.print;

public class Square extends Shape {
    public void draw() { print("Square.draw()"); }
    public void erase() { print("Square.erase()"); }
}/* Square output

 *///:~
```

Triangle

```java
/**
 * @FilePath Polymorphism/Triangle.java
 * @Author
 * @Date 2019/9/7 17:41
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Shape;import static hkeysen.utils.Print.print;

public class Triangle extends Shape {
    public void draw() { print("Triangle.draw()"); }
    public void erase() { print("Triangle.erase()"); }
}/* Triangle output

 *///:~
```

RandomShapeGenerator

```java
/**
 * @FilePath Polymorphism/RandomShapeGenerator.java
 * @Author
 * @Date 2019/9/7 17:43
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Circle;import Polymorphism.demo.Shape;import Polymorphism.demo.Square;import Polymorphism.demo.Triangle;import java.util.Random;

public class RandomShapeGenerator {
    private Random rand = new Random(1373);
    public Shape next() {
        switch(rand.nextInt(3)) {
            default:
            case 0: return new Circle();
            case 1: return new Square();
            case 2: return new Triangle();
        }
    }
}/* RandomShapeGenerator output

 *///:~
```

多态的应用

```java
/**
 * @FilePath Polymorphism/Exercise2.java
 * @Author
 * @Date 2019/9/7 17:35
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.RandomShapeGenerator;import Polymorphism.demo.Shape;public class Exercise2 {
    private static RandomShapeGenerator gen = new RandomShapeGenerator();
    public static void main(String[] args) {
        Shape[] s = new Shape[10];
        // fill up the array wth shapes:
        for(int i = 0; i < s.length; i++)
            s[i] = gen.next();
        // make polymorphic method calls:
        for(Shape shp : s)
            shp.draw();
    }
}/* Exercise2 output
Triangle.draw()
Triangle.draw()
Circle.draw()
Triangle.draw()
Square.draw()
Square.draw()
Circle.draw()
Square.draw()
Square.draw()
Circle.draw()
 *///:~
```

> 练习2：
>
> 在上述示例中添加@Override注解

Circle

```java
/**
 * @FilePath Polymorphism/Circle.java
 * @Author
 * @Date 2019/9/7 17:39
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Shape;import static hkeysen.utils.Print.print;

public class Circle extends Shape {
    @Override
    public void draw() { print("Circle.draw()"); }

    @Override
    public void erase() { print("Circle.erase()"); }
}/* Circle output

 *///:~
```

Square

```java
/**
 * @FilePath Polymorphism/Square.java
 * @Author
 * @Date 2019/9/7 17:40
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Shape;import static hkeysen.utils.Print.print;

public class Square extends Shape {
    @Override
    public void draw() { print("Square.draw()"); }

    @Override
    public void erase() { print("Square.erase()"); }
}/* Square output

 *///:~
```

Triangle

```java
/**
 * @FilePath Polymorphism/Triangle.java
 * @Author
 * @Date 2019/9/7 17:41
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.Shape;import static hkeysen.utils.Print.print;

public class Triangle extends Shape {
    @Override
    public void draw() { print("Triangle.draw()"); }

    @Override
    public void erase() { print("Triangle.erase()"); }
}/* Triangle output

 *///:~
```

再测试

```java
/**
 * @FilePath Polymorphism/Exercise2.java
 * @Author
 * @Date 2019/9/7 17:35
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import Polymorphism.demo.RandomShapeGenerator;import Polymorphism.demo.Shape;public class Exercise2 {
    private static RandomShapeGenerator gen = new RandomShapeGenerator();
    public static void main(String[] args) {
        Shape[] s = new Shape[10];
        // fill up the array wth shapes:
        for(int i = 0; i < s.length; i++)
            s[i] = gen.next();
        // make polymorphic method calls:
        for(Shape shp : s)
            shp.draw();
    }
}/* Exercise2 output
Triangle.draw()
Triangle.draw()
Circle.draw()
Triangle.draw()
Square.draw()
Square.draw()
Circle.draw()
Square.draw()
Square.draw()
Circle.draw()
 *///:~
```

> 练习3：
>
> 在基类Shape.java中添加一个新方法，用于打印一条信息，但在导出类中不要覆盖这个方法；覆盖其中一个导出类的方法；覆盖所有导出类的方法。观察得到的结果。

结果都相同。

> 练习4：
>
> 在Shape.java中添加一个新的Shape类型，并在main()方法中验证：多态对新类型的作用是否域在旧类型中一样。

一样。

> 练习5：
>
> 以练习1为基础，在Cycle中添加wheels()方法，它将返回轮子的数量。修改ride()方法，让它调用wheels()方法，并验证多态起了作用。

```java
/**
 * @FilePath Polymorphism/Exercise1.java
 * @Author
 * @Date 2019/9/7 16:28
 * @Version 1.0.0
 * @Description
 */

package Polymorphism;

import static hkeysen.utils.Print.*;

class Cycle{
    private String name = "Cycle";
    private int wheels = 0;
    public void travel(Cycle c){
        print("Cycle.ride() " + c);
    }
    public int wheels() {
        return wheels;
    }
    public String toString() {
        return this.name;
    }
}

class Unicycle extends Cycle {
    private String name = "Unicycle";
    private int wheels = 1;
    @Override public int wheels() { return wheels; }
    public String toString() {
        return this.name;
    }
}

class Bicycle extends Cycle {
    private String name = "Bicycle";
    private int wheels = 2;
    @Override public int wheels() { return wheels; }
    public String toString() {
        return this.name;
    }

}

class Tricycle extends Cycle {
    private String name = "Tricycle";
    private int wheels = 3;
    @Override public int wheels() { return wheels; }
    public String toString() {
        return this.name;
    }
}


public class Exercise1 {
    public static void ride(Cycle cycle) {
        cycle.travel(cycle);
        print("Wheels: " + cycle.wheels());
    }

    public static void main(String[] args) {
        Unicycle unicycle = new Unicycle();
        Bicycle bicycle = new Bicycle();
        Tricycle tricycle = new Tricycle();
        ride(unicycle);
        ride(bicycle);
        ride(tricycle);
    }
}/* Exercise1 output
without adding wheels():
Cycle.ride() Unicycle
Cycle.ride() Bicycle
Cycle.ride() Tricycle

After add wheels():
Cycle.ride() Unicycle
Wheels: 1
Cycle.ride() Bicycle
Wheels: 2
Cycle.ride() Tricycle
Wheels: 3
 *///:~
```

