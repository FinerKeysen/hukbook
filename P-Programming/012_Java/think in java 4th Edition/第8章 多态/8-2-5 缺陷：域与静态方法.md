不是所有事物都可以多态的发生。

注意的是，只有普通方法调用可以时多态的。

- 域

如果你直接访问某个域，这个访问就将在编译期进行解析。

示例：

```java
//: polymorphism/FieldAccess.java
// Direct field access is determined at compile time.

class Super {
  public int field = 0;
  public int getField() { return field; }
}

class Sub extends Super {
  public int field = 1;
  public int getField() { return field; }
  public int getSuperField() { return super.field; }
}

public class FieldAccess {
  public static void main(String[] args) {
    Super sup = new Sub(); // Upcast
    System.out.println("sup.field = " + sup.field +
      ", sup.getField() = " + sup.getField());
    Sub sub = new Sub();
    System.out.println("sub.field = " +
      sub.field + ", sub.getField() = " +
      sub.getField() +
      ", sub.getSuperField() = " +
      sub.getSuperField());
  }
} /* Output:
sup.field = 0, sup.getField() = 1
sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0
*///:~
```

当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态。Sub实际上包含有两个称为field的域，自己的域Sub.field和从Super那里得到的域Super.field。



在实际工程中，这种情况一般不会发生。因为通常会将所有的域都设置成private，因此不能直接访问它们，其副作用是只能调用方法来访问。此外，你可能不会对基类中的域和导出类中的域采用相同的名字，这样容易令人混淆。



- 静态方法

如果某个方法是静态的，它的行为就不具有多态性

示例：

```java
//: polymorphism/StaticPolymorphism.java
// Static methods are not polymorphic.

class StaticSuper {
  public static String staticGet() {
    return "Base staticGet()";
  }
  public String dynamicGet() {
    return "Base dynamicGet()";
  }
}

class StaticSub extends StaticSuper {
  public static String staticGet() {
    return "Derived staticGet()";
  }
  public String dynamicGet() {
    return "Derived dynamicGet()";
  }
}

public class StaticPolymorphism {
  public static void main(String[] args) {
    StaticSuper sup = new StaticSub(); // Upcast
    System.out.println(sup.staticGet());
    System.out.println(sup.dynamicGet());
  }
} /* Output:
Base staticGet()
Derived dynamicGet()
*///:~
```

静态方法是与类相关联的，而非仅与单个的对象相关联。

