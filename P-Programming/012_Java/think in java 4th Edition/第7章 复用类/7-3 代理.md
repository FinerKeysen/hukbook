代码复用的第三种关系为代理，Java没有提供对它的直接支持。代理方式处于继承与组合之间，拥有它们的某些特点：将一个成员对象置于所要构造的类中（像组合），但同时在新类中暴露了该成员对象的所有方法（像继承）。

示例：

```java
//: reusing/SpaceShipControls.java

public class SpaceShipControls {
  void up(int velocity) {}
  void down(int velocity) {}
  void left(int velocity) {}
  void right(int velocity) {}
  void forward(int velocity) {}
  void back(int velocity) {}
  void turboBoost() {}
} ///:~
```

采用继承的方法时：

```Java
//: reusing/SpaceShip.java

public class SpaceShip extends SpaceShipControls {
  private String name;
  public SpaceShip(String name) { this.name = name; }
  public String toString() { return name; }
  public static void main(String[] args) {
    SpaceShip protector = new SpaceShip("NSEA Protector");
    protector.forward(100);
  }
} ///:~
```

1、SpaceShipControls类的所有方法在SpaceShip中都暴露了出来

采用代理的形式：

```java
//: reusing/SpaceShipDelegation.java

public class SpaceShipDelegation {
  private String name;
  private SpaceShipControls controls =
    new SpaceShipControls();
  public SpaceShipDelegation(String name) {
    this.name = name;
  }
  // Delegated methods:
  public void back(int velocity) {
    controls.back(velocity);
  }
  public void down(int velocity) {
    controls.down(velocity);
  }
  public void forward(int velocity) {
    controls.forward(velocity);
  }
  public void left(int velocity) {
    controls.left(velocity);
  }
  public void right(int velocity) {
    controls.right(velocity);
  }
  public void turboBoost() {
    controls.turboBoost();
  }
  public void up(int velocity) {
    controls.up(velocity);
  }
  public static void main(String[] args) {
    SpaceShipDelegation protector =
      new SpaceShipDelegation("NSEA Protector");
    protector.forward(100);
  }
} ///:~
```

代理的方式拥有更多的控制力，因为我们可以选择只提供在成员对象中的方法的某个子集，也即是说可以选择只提供某一部分接口。

> 练习：修改7-2中的Detergent，以代理形式实现

示例：

```java
/**
 * @FilePath reusing/Exercise11.java
 * @Author
 * @Date 2019/9/1 16:07
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Cleanser {
    private String s = "Cleanser";
    public void append(String a) { s += a;}
    public void dilute() {append(" dilute()");}
    public void apply() {append(" apply()");}
    public void scrub() {append(" srcub()");}
    public String toString() {return s;}
    public static void main(String[] args) {
        Cleanser x = new Cleanser();
        x.dilute();
        x.apply();
        x.scrub();
        print(x);
    }
}

class Detergent extends Cleanser {
    // change a method
    public void scrub() {
        append(" Detergent.scrub()");
        super.scrub(); // callback base-class version
    }

    // add methods to the interface
    public void foam() {
        append(" form()");
    }

    // Test the new class
    public static void main(String[] args) {
        Detergent x = new Detergent();
        x.dilute();
        x.apply();
        x.scrub();
        x.foam();
        print(x);
        print("Testing base class: ");
        Cleanser.main(args);
    }
}

public class Exercise11 { // 以代理的方式实现Delegent的功能
    private String s = "DetergenTelegation";
    private Cleanser cls = new Cleanser();

    public void append(String a) {
        s += a;
    }

    // method in Cleanser
    public void dilute() {
        cls.dilute();
    }

    public void apply() {
        cls.apply();
    }

    // method in Exercise11
    public void scrub() {
        append(" DetergentDelegation.scrub()");
        cls.scrub();
    }
    public void form() {
        append(" form()");
    }

    public String toString() {
        return s + " " + cls;
    }

    public static void main(String[] args) {
        Exercise11 e = new Exercise11();
        e.dilute();
        e.apply();
        e.scrub();
        e.form();
        print(e);
        print("Testing base class: ");
        Cleanser.main(args);
    }
}/* Exercise11 output
DetergenTelegation DetergentDelegation.scrub() form() Cleanser dilute() apply() srcub()
Testing base class:
Cleanser dilute() apply() srcub()
 *///:~
```

