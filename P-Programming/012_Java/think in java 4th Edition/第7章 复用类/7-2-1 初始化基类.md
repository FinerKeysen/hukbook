继承不只是复制基类的接口。

当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。

初始化时，Java会自动在导出类的构造器中插入对基类构造器的调用。

示例：

```java
/**
 * @FilePath reusing/Cartoon.java
 * @Author
 * @Date 2019/8/31 15:52
 * @Version 1.0.0
 * @Description 继承时的构造器调用
 */

package reusing;

import static hkeysen.utils.Print.*;

class Art {
    Art() {
        print("Art constructor");
    }
}

class Drawing extends Art {
    Drawing() {
        print("Drawing constructor");
    }
}

public class Cartoon extends Drawing {
    public Cartoon() {
        print("Cartoon constructor");
    }

    public static void main(String[] args) {
        Cartoon x = new Cartoon();
    }
}/* Cartoon output
Art constructor
Drawing constructor
Cartoon constructor
*///:~

```

Notes：

1、构造过程从基类“向外”扩散。因此，基类在导出类构造器可访问它之前就已经完成了初始化。

2、即使不创建`Cartoon()`构造器，编译器也会自动合成一个默认的构造器。该构造器将调用基类的构造器。

示例证明：

```java
/**
 * @FilePath reusing/Cartoon.java
 * @Author
 * @Date 2019/8/31 15:52
 * @Version 1.0.0
 * @Description 继承时的构造器调用
 */

package reusing;

import reusing.demo.Cartoon;import static hkeysen.utils.Print.*;

class Art {
    Art() {
        print("Art constructor");
    }
}

class Drawing extends Art {
    Drawing() {
        print("Drawing constructor");
    }
}

public class Cartoon2 extends Drawing {
    public static void main(String[] args) {
        Cartoon x = new Cartoon2();
    }
}/* Cartoon2 output
Art constructor
Drawing constructor
*///:~
```

> 练习，请证明基类的构造器：（a）总是被调用（b）在导出类构造器之前被调用

```java
/**
 * @FilePath reusing/Exercise4.java
 * @Author
 * @Date 2019/8/31 16:11
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class A {A() {print("A()");}}

class B extends A {B() {print("B()");}}

class C extends B {C() {print("C()");}}

class D extends C {
    D() {print("D()");}
    public static D make() {
        return new D();
    }

    public static void main(String[] args) {
        D d1 = new D();
        D d2 = make();
    }
}

public class Exercise4 extends D {
    Exercise4() {
        print("Exercise4()");
    }
    public static void main(String[] args) {
        Exercise4 e = new Exercise4();
        D.main(args);
    }
}/* Exercise4 output
A()
B()
C()
D()
Exercise4()
A()
B()
C()
D()
A()
B()
C()
D()
*///:~
```



> 练习：创建两个带有默认构造器（空参列表）的类A和类B。从A中继承产生一个名为C的新类，并在C内创建一个类B的成员，不要给C编写构造器。创建一个类C，观察其结果。

本题中以`Exercise5`代替`C`

```java
/**
 * @FilePath reusing/ExerciseFive.java
 * @Author
 * @Date 2019/8/31 16:27
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class A {
    A() {print("A()");}
}

class B extends A {
    B() {print("B()");}
}

public class Exercise5 extends A {
    B bExercise5 = new B(); // 然后构建另一个A和一个B
    public static void main(String[] args) {
        Exercise5 c = new Exercise5(); // 先构建A
    }
}/* Exercise5 output
A()
A()
B()
 *///:~
```



