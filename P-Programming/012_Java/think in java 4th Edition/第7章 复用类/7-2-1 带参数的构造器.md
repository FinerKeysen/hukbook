当基类构造器都不带参数，编译器会调用默认构造器。但是，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，必须使用关键字`super`显式地编写调用基类构造器的语句，并配备适当的参数列表。

示例：

```java
/**
 * @FilePath reusing/Chess.java
 * @Author
 * @Date 2019/8/31 16:46
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Game {
    Game(int i) {
        print("Game constructor.");
    }
}

class BoardGame extends Game {
    BoardGame(int i) {
        super(i);
        print("BoardGame constructor.");
    }
}

public class Chess extends BoardGame {
    Chess(){
        super(10);
        print("Chess constructor.");
    }

    public static void main(String[] args) {
        Chess c = new Chess();
    }
}/* Chess output
Game constructor.
BoardGame constructor.
Chess constructor.
 *///:~
```

> 练习：创建两个带参构造器（空参列表）的类A和类B。从A中继承产生一个名为C的新类，并在C内创建一个类B的成员，给C编写构造器，并在其中执行所有的初始化。

```java
/**
 * @FilePath reusing/Exercise7.java
 * @Author
 * @Date 2019/8/31 16:52
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class A {
    A(int i) {print("A()");}
}

class B extends A {
    B(int i) {
        super(i);
        print("B()");
    }
}

class C extends A {
    private int i;
    private B a = new B(4); //然后构建另一个A和一个B
    C(int j) {
        super(j);
        i = j;
    }
}

public class Exercise7 {
    public static void main(String[] args) {
        C c = new C(8); //先构建A
    }
}/* Exercise7 output
A()
A()
B()
 *///:~
```

> 练习：创建一个基类，它仅有一个非默认的构造器，再创建一个导出类，它带有默认构造器和非默认构造器。在导出类的构造器中调用基类的构造器。

```java
/**
 * @FilePath reusing/Exercise8.java
 * @Author
 * @Date 2019/8/31 16:56
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class A {
    A(int i) {print("A()");}
}

class C extends A {
    C() {
        super(10);
    }

    C(String s) {
        super(8);
        print(s);
    }
}

public class Exercise8 {
    public static void main(String[] args) {
        C c1 = new C();
        C c2 = new C("Hello.");
    }
}/* Exercise8 output
A()
A()
Hello.
 *///:~
```

> 练习：创建一个Root类，令其含有名为Component1、Component2、Component3的类的各一个实例。从Root中派生一个类Stem，也含有上述各组成部分，所有的类都应带有可打印的相关信息的默认的构造器。

本题中以`Exercise9`代替`Stem`

```java
/**
 * @FilePath reusing/Exercise9.java
 * @Author
 * @Date 2019/8/31 16:58
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Component1 {
    Component1() {print("Component1 constructor.");}
}

class Component2 {
    Component2() {print("Component2 constructor.");}
}

class Component3 {
    Component3() {print("Component3 constructor.");}
}

class Root {
    Component1 c1;
    Component2 c2;
    Component3 c3;

    Root() {
        print("Root constructor.");
    }
}

class Exercise9 extends Root{
    Component1 c1exercise;
    Component2 c2exercise;
    Component3 c3exercise;
    Exercise9() {
        print("Exercise9 constructor.");
    }
    public static void main(String[] args) {
        Exercise9 s = new Exercise9();
    }
}/* Exercise9 output
Root constructor.
Exercise9 constructor.
 *///:~
```

> 练习：修改上述练习，使每个类都仅具有非默认的构造器。

本题中以`Exercise10`代替`Stem`

```java
/**
 * @FilePath reusing/Exercise10.java
 * @Author
 * @Date 2019/9/1 14:26
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Component1 {
    Component1(char c) {print("Component1(char)");}
}

class Component2 {
    Component2(int i) {print("Component2(int)");}
}

class Component3 {
    Component3(float f) {print("Component3(float)");}
}

class Root {
    Component1 c1;
    Component2 c2;
    Component3 c3;

    Root(int i) {
        c1 = new Component1('h');
        c2 = new Component2(1);
        c3 = new Component3(2.1f);
        print("Root(int)");
    }
}

class Exercise10 extends Root{
    Component1 c1exercise10;
    Component2 c2exercise10;
    Component3 c3exercise10;
    Exercise10(double f) {
        super(2);
        c1exercise10 = new Component1('k');
        c2exercise10 = new Component2(5);
        c3exercise10 = new Component3(8.6f);
        print("Exercise10(double)");
    }
    public static void main(String[] args) {
        Exercise10 s = new Exercise10(3.14);
    }
}/* Exercise10 output
Component1(char)
Component2(int)
Component3(float)
Root(int)
Component1(char)
Component2(int)
Component3(float)
Exercise10(double)
 *///:~
```

