如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称时并不会屏蔽其在基类中的任何版本。这与C++中不同。因此，无论是在该层还是它的基类中对方法进行定义，重载机制都可以正常工作。

示例：

```java
/**
 * @FilePath reusing/Hide.java
 * @Author
 * @Date 2019/9/1 18:20
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Homer {
    char doh(char c) {
        print("doh(char)");
        return c;
    }
    float doh(float f) {
        print("doh(float)");
        return f;
    }
}
class Milhouse {}

class Bart extends Homer {
    void doh(Milhouse m) {
        print("doh(Milhouse)");
    }
    char doh(int m) {
        print("doh(int)");
        return 'c';
    }
    char doh(char c) {
        print("Bart.doh(char)");
        return c;
    }
}
public class Hide {
    public static void main(String[] args) {
        Bart b = new Bart();
        b.doh(1);
        b.doh(new Milhouse());
        b.doh('h');
        b.doh(3.14f);
    }
}/* Hide output
doh(int)
doh(Milhouse)
Bart.doh(char)
doh(float)
 *///:~
```

Notes：

1、使用与基类完全相同的特征签名及返回类型来覆盖具有相同名称的方法，在java中很正常。但是会产生困惑，有时无法分辨来源，这也是为什么C++中不允许这样做的原因——防止犯错。C++中若要完成这项工作需要屏蔽基类方法。

2、Java SE5中新增了@Override注解，它不是关键字，但可当作关键字来使用。当要覆写某个方法时，可以添加这个注解。当你想重载而并非覆写时用了该注解就会报错。如：

```java
class Lisa extends Homer {
    @Override
    void doh(char c) { // error
        print("doh(char)");
    }
}
```

`Lisa`继承自`Homer`，想要覆写`doh(char)`，但是`Homer`中不存在放回类型为`void`的`doh(char)`，会报错返回类型不兼容。因此注解`@Override`能防止你在不想重载时而意外地进行了重载。

