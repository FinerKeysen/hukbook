析构函数是一种在对象被销毁时可以被自动调用的函数。**但在Java中没有C++中析构函数的概念。**Java中通过垃圾回收器自动在必要时释放其内存，但问题是我们并不知道垃圾回收器何时将会被调用，或者它是否将被调用。在类有时可能需要在其生命周期内执行一些必须的清理活动时，自动进行垃圾回收的机制就会产生问题。

因此，如果想要某个类清理一些东西，就必须显示地编写一个特殊方法来完成这件事，并确保客户端程序员知晓他们必须要调用这一方法。

那么首要任务就是，必须将这一清理动作置于finally子句中，以预防异常出现。

示例：

```java
/**
 * @FilePath reusing/CADSystem.java
 * @Author
 * @Date 2019/9/1 17:48
 * @Version 1.0.0
 * @Description
 */

package reusing;

import java.util.List;

import static hkeysen.utils.Print.*;

class Shape {
    Shape(int i) {
        print("Shape constructor");
    }

    void dispose() {
        print("Shape dispose"); // 此处仅是演示,实际需要编写垃圾清理的代码
    }
}

class Circle extends Shape{
    Circle(int i) {
        super(i);
        print("Drawing Circle");
    }

    void dispose() {
        print("Erasing Circle");
        super.dispose();
    }
}

class Triangle extends Shape {
    Triangle(int i) {
        super(i);
        print("Drawing Triangle");
    }
    void dispose() {
        print("Erasing Triangle");
        super.dispose();
    }
}

class  Line extends Shape {
    private int start, end;
    Line(int start, int end) {
        super(start);
        this.start = start;
        this.end = end;
        print("Drawing Ling: " + start + ", " + end);
    }

    void dispose() {
        print("Erasing Ling: " + start + ", " + end);
        super.dispose();
    }
}

public class CADSystem extends Shape{
    private Circle c;
    private Triangle t;
    private Line[] lines = new Line[3];
    public CADSystem(int i) {
        super(i);
        for(int j=0; j<lines.length; j++){
            lines[j] = new Line(j, j*j);
        }
        c = new Circle(2);
        t = new Triangle(3);
        print("Combined constructor");
    }

    public void dispose() {
        print("CADSystem dispose");
        t.dispose();
        c.dispose();
        for(int j=lines.length-1; j>=0; j--) {
            lines[j].dispose();
        }
        super.dispose();
    }

    public static void main(String[] args) {
        CADSystem cad = new CADSystem(88);
        try {

        } finally {
            cad.dispose();
        }
    }
}/* CADSystem output
Shape constructor
Shape constructor
Drawing Ling: 0, 0
Shape constructor
Drawing Ling: 1, 1
Shape constructor
Drawing Ling: 2, 4
Shape constructor
Drawing Circle
Shape constructor
Drawing Triangle
Combined constructor
CADSystem dispose
Erasing Triangle
Shape dispose
Erasing Circle
Shape dispose
Erasing Ling: 2, 4
Shape dispose
Erasing Ling: 1, 1
Shape dispose
Erasing Ling: 0, 0
Shape dispose
Shape dispose
 *///:~
```

Notes：

1、每个类都有自己的`dispose()`方法将未存于内存中的东西恢复到对象存在之前的状态。

2、关键字`try`表示其所属块是所谓的保护区，需要被特殊处理。关键字`finally`表示无论`try`块是怎么样退出的，它总是要被执行。

3、在清理方法（`dispose()`）中，必须注意对基类清理方法和成员对象清理方法的调用顺序，以防某个子对象依赖于另一个子对象情形的发生。采用的形式与C++编译器在其析构函数上施加的形式相同：首先，执行类的所有特定的清理工作，其顺序同生成顺序相反；然后，如上述示范那样，调用基类的清理方法。
