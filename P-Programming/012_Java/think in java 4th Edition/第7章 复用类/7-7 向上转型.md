新类与基类之间的关系：新类是现有类的一种类型

示例：

```java
/**
 * @FilePath reusing/Wind.java
 * @Author
 * @Date 2019/9/1 19:54
 * @Version 1.0.0
 * @Description
 */

package reusing;

class Instruments {
    public void play() {}
    static void tune(Instruments i) {
        i.play();
    }
}

public class Wind extends Instruments{
    public static void main(String[] args) {
        Wind w = new Wind();
        Instruments.tune(w); // upcasting,向上转型
    }
}/* Wind output

 *///:~
```

Notes：

`tune()`方法应该接受`Instruments`引用，但在`Wind.main()`方法中，传递给`tune()`方法却是一个`Wind`引用。除非`Wind`是一个`Instruments`对象。这种将`Wind`引用转换为`Instruments`引用的动作称为**向上转型**。

7.7.1 

向上转型：由导出类转型成基类；

特点：从一个较专用类型转向较通用类型，总是很安全的。导出类是基类的一个超集，它可能比基类含有更多的方法，但必须至少具备基类中所含有的方法。

7.7.2 再论组合和继承

尽管在日常中我们强调继承的次数比较多，但并不意味着要尽可能使用它。因根据场合来确定。

一个清晰的判断方法是：是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的；但如果不需要，则应当考虑有无必要使用继承。

> 练习：创建一个名为`Amphibian`的类。由此继承产生一个称为`Frog`得类。在基类中设置适当的方法。在`main()`中，创建一个`Frog`并向上转型之`Amphibian`，并说明所有方法都可工作。

```java
/**
 * @FilePath reusing/Frog.java
 * @Author
 * @Date 2019/9/1 20:13
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Amphibian {
    protected void swim() {
        print("Amphibian swim");
    }
    protected void speak() {
        print("Amphibian speak");
    }
    void eat() {
        print("Amphibian eat");
    }
    static void grow(Amphibian a) {
        print("Amphibian grow");
        a.eat();
    }
}

public class Frog extends Amphibian {
    public static void main(String[] args) {
        Frog f = new Frog();
        // call base-class methods:
        f.swim();
        f.speak();
        f.eat();
        // upcast Frog to Amphibian argument:
        Amphibian.grow(f);
    }
}/* Frog output
Amphibian swim
Amphibian speak
Amphibian eat
Amphibian grow
Amphibian eat
 *///:~
```



> 练习：修改上述练习，使`Frog`覆盖基类中方法的定义。注意`main()`中的变化。

```java
/**
 * @FilePath reusing/Frog.java
 * @Author
 * @Date 2019/9/1 20:13
 * @Version 1.0.0
 * @Description
 */

package reusing;

import static hkeysen.utils.Print.*;

class Amphibian {
    protected void swim() {
        print("Amphibian swim");
    }
    protected void speak() {
        print("Amphibian speak");
    }
    void eat() {
        print("Amphibian eat");
    }
    static void grow(Amphibian a) {
        print("Amphibian grow");
        a.eat();
    }
}

public class Frog extends Amphibian {

    @Override
    protected void swim() {
        print("Frog swim");
    }

    @Override
    protected void speak() {
        print("Frog speak");
    }

    @Override
    void eat() {
        print("Frog eat");
    }

    static void grow(Amphibian a) {
        print("Frog grow");
        a.eat();
    }

    public static void main(String[] args) {
        Frog f = new Frog();
        // call overridden base-class methods:
        f.swim();
        f.speak();
        f.eat();
        // upcast Frog to Amphibian argument
        f.grow(f);
        // upcast Frog to Amphibian argument and call Alphibian method:
        Amphibian.grow(f);
    }
}/* Frog output
Frog swim
Frog speak
Frog eat
Frog grow
Frog eat
Amphibian grow
Frog eat
 *///:~
```

