假设有一Processor类，它有一个name()方法和一个process()方法。process()方法可接受输入参数，修改它的值，然后产生输出。这个类作为基类被扩展，用以创建各种不同类型的Processor。

下面示例将修改String对象

```java
/**
 * @FilePath interfaces.demo.ch9_3/Apply.java
 * @Author
 * @Date 1/6/2020 2:36 PM
 * @Version 1.0.0
 * @Description
 */

package interfaces.demo.ch9_3;

import java.util.Arrays;

import static hk.util.Print.print;

class Processor {
    public String name() {
        return getClass().getSimpleName();
    }

    Object process(Object input) {
        return input;
    }
}

class Upcase extends Processor {
    @Override
    String process(Object input) {
        return ((String)input).toUpperCase();
    }
}

class Downcase extends Processor {
    @Override
    String process(Object input) {
        return ((String)input).toLowerCase();
    }
}

class Splitter extends Processor {
    @Override
    String process(Object input) {
        return Arrays.toString(((String)input).split(" "));
    }
}
public class Apply {
    public static void process(Processor p, Object s) {
        print("Using Processor " + p.name());
        print(p.process(s));
    }

    public static String str = "Hello, think in Java. I am learning java with Edition 4th.";

    public static void main(String[] args) {
        process(new Upcase(), str);
        process(new Downcase(), str);
        process(new Splitter(), str);
    }
}/* Apply output
Using Processor Upcase
HELLO, THINK IN JAVA. I AM LEARNING JAVA WITH EDITION 4TH.
Using Processor Downcase
hello, think in java. i am learning java with edition 4th.
Using Processor Splitter
[Hello,, think, in, Java., I, am, learning, java, with, Edition, 4th.]
 *///:~
```



Apply.process()方法可接受任何类型的Processor，并将其应用到一个Object对象上，然后打印结果。

这样创建一个能够根据所传递的参数对象的不同而具有不同行为的方法被称为**策略设计模式**。这类方法包含要执行的算法中固定不变的部分，而“策略”包含变化的部分。

策略就是要传进去的参数对象，它包含要执行的代码。

示例中，Processor对象就是一个策略，main()中看出有三种不同类型的策略应用到了String类型的str对象上。

